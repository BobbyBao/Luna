
let unpack = unpack or table.unpack

func async_to_sync(async_func, callback_pos) {
    return func(...) {
        let _co = coroutine.running() or error ('this function must be run in coroutine')
        var rets
        var waiting = false
        local func cb_func(...) {
            if waiting {
                assert(coroutine.resume(_co, ...))
            } else {
                rets = {...}
            }
        }
        let params = {...}
        table.insert(params, callback_pos or (#params + 1), cb_func)
        async_func(unpack(params))
        if rets == nil {
            waiting = true
            rets = {coroutine.yield()}
        }
        
        return unpack(rets)
    }
}

func coroutine_call(fn) {
    return func(...) {
        local co = coroutine.create(fn)
        assert(coroutine.resume(co, ...))
    }
}

let move_end = {}

let generator_mt = {
    __index = {
        MoveNext = func(self) {
            self.Current = self.co()
            if self.Current == move_end {
                self.Current = nil
                return false
            } else {
                return true
            }
        },

        Reset = func(self) {
            self.co = coroutine.wrap(self.w_func)
        }
    }
}

func cs_generator(fn, ...) {
    let params = {...}
    let generator = setmetatable({
        w_func = func() {
            fn(unpack(params))
            return move_end
        }
    }, generator_mt)
    generator.Reset()
    return generator
}

func coroutine.start(...) {
    return startCoroutine(cs_generator(...))
}

func coroutine.stop(c) {
    stopCoroutine(c)
}
